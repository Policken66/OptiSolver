import re
from dataclasses import dataclass
from pathlib import Path
from typing import List, Dict, Any


@dataclass
class RenderReport:
    """Краткий отчет о подстановке параметров в APDL."""
    replaced: List[str]  # какие имена нашли в тексте и заменили
    inserted: List[str]  # какие имена не нашли и вставили в шапку
    total_expected: int  # сколько ключей пришло всего
    output_path: Path  # путь к итоговому input.apdl


class TemplateRenderError(Exception):
    pass


_ASSIGN_RE_CACHE: Dict[str, re.Pattern] = {}


def _assign_pattern(name: str) -> re.Pattern:
    """
    Регулярное выражение для строки присваивания APDL переменной 'name':
    - начало строки ^name
    - произвольные пробелы, знак '=', произвольная правая часть до конца строки (сохраняем хвост)
    :param name:
    :return:
    """
    if name not in _ASSIGN_RE_CACHE:
        # (?m) - многострочный режим, ^ и $ якорятся к строкам
        _ASSIGN_RE_CACHE[name] = re.compile(rf"(?m)^(?P<lhs>\s*{re.escape(name)}\s*=\s*(?P<rhs>[^\n\r]*)$")
    return _ASSIGN_RE_CACHE[name]


def _format_value(val: Any) -> str:
    """
    Форматируем Python-значение в строку APDL.
    Для float - используем компактный формат без лишних нулей.
    :param val:
    :return:
    """
    if isinstance(val, float):
        # 12 значащих цифр достаточно для инженерных величин; уберем лишние нули и точку
        s = f"{val:.12g}"
        return s
    return str(val)


def render_apdl(template_path: Path, params: Dict[Any, str], output_path: Path) -> RenderReport:
    """
    Модифицирует APDL-шаблон:
    - заменяет правые части присваиваний известных переменных (если найдены);
    - добавляет в начало файла блок инициализации для переменных, которых нет в тексте.

    :param template_path:
    :param params:
    :param output_path:
    :return:
    """
    template_path = Path(template_path)
    output_path = Path(output_path)

    if not template_path.exists():
        raise TemplateRenderError(f"Шаблон не найден: {template_path}")

    text = template_path.read_text(encoding="utf-8")

    replaced: List[str] = []
    missing: List[str] = []

    # 1) пытаемся заменить присваивания "на месте"
    for name, value in params.items():
        pattern = _assign_pattern(name)

        def _sub_once(m: re.Match) -> str:
            # сохраняем левую часть (включая пробелы и '=') и хвост комментария из rhs
            # lhs - left hand side; rhs - right hand side
            lhs = m.group("lhs")
            rhs = m.group("rhs")
            # если в rhs был комментарий, сохраним его после пробела
            # разделим по '!' только один раз
            if "!" in rhs:
                code, comment = rhs.split("!", 1)
                new_rhs = f"{_format_value(value)} !{comment}"
            else:
                new_rhs = _format_value(value)
            return lhs + new_rhs

        new_text, count = pattern.subn(_sub_once, text, count=1)
        if count > 0:
            text = new_text
            replaced.append(name)
        else:
            missing.append(name)

    # 2) если какие-то переменные не нашлись - добавим инициализирующий блок в начало
    if missing:
        header_lines = [
            "! ====== AUTOGENERATED PARAM HEADER (do not edit) ======",
            "! Вставлено препроцессором: значения переопределяют дефолты ниже"
        ]
        for name in missing:
            header_lines.append(f"{name} = {_format_value(params[name])}    ! set by preprocessor")
        header_lines.append("! ==================================================================")
        header_block = "\n".join(header_lines) + "\n\n"
        text = header_block + text

    # 3) записываем результат
    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text(text, encoding="utf-8")

    return RenderReport(
        replaced=replaced,
        inserted=missing,
        total_expected=len(params),
        output_path=output_path,
    )
